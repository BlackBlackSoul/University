\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{ulem}

\renewcommand<>{\sout}[1]{
    \alt#2{\beameroriginal{\sout}{#1}}{#1}
}

% \includeonlyframes{current}


\newcommand{\n}{\,\\}

\usetheme{Boadilla}

\title{Początki Lispu}
\subtitle{(((Archeologia Cyfrowa)))}
\author{Jakub Grobelny}
\date{19.11.2019}

\begin{document}

%==============================================================================%

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{O czym będzie?}
\tableofcontents
\end{frame}

%==============================================================================%

\section{Do czego był potrzebny taki język?}
\begin{frame}
\frametitle{Narodziny sztucznej inteligencji}
\pause
Lata 50. XX wieku były czasem, gdy sztuczna inteligencja pojawiła się jako 
dziedzina wiedzy.
\pause
\begin{description}
    \item[1950] Alan Turing publikuje ,,\textit{Computing Machinery 
                and Intelligence}''
        \begin{itemize}
            \item \pause 
                \only<-5>{,,\textit{Czy maszyny myślą?}''}
                \only<6-7>{\sout{,,\textit{Czy maszyny myślą?}''}}
            \item \pause 
                \only<-5>{,,\textit{Czy maszyny mogą myśleć?}''}
                \only<6-7>{\sout{,,\textit{Czy maszyny mogą myśleć?}''}}
            \item \pause,,\textit{Czy maszyny mogą działać nieodróżnialnie od ludzi?}''
        \end{itemize} \pause
    \item[1951] Pierwsze programy grające w warcaby (Christopher 
                Strachey) i szachy (Dietrich Prinz)
\end{description}
\end{frame}

\begin{frame}
\frametitle{Narodziny sztucznej inteligencji}
\begin{description}
    \item[1955] Allen Newell, Herbert A. Simon i Cliff Shaw
                tworzą program ,,\textit{Logic Theorist}'' \pause
        \begin{itemize}
            \item Program naśladujący ludzkie techniki rozwiązywania 
                  problemów \pause
            \item Program manipulujący \textbf{symbolami} \pause
            \item Udowodnił 38 z pierwszych 52 twierdzeń z ,,\textit{Principia 
                  Mathematica}''\footnotemark \pause \,(niektóre z dowodów były 
                  bardziej eleganckie niż wcześniej istniejące) \pause
        \end{itemize}
\end{description}

\only<4-5>{\footnotetext[2]{Autorstwa Alfreda Northa Whiteheada i Bertranda 
                            Russella}}
\end{frame}


\begin{frame}
\frametitle{Narodziny sztucznej inteligencji}

\begin{columns}
\column{0.5\textwidth}

\begin{description}
    \item[1956] Konferencja w Dartmouth. \pause
                \textbf{John McCarthy} przekonuje zebranych do
                używania terminu ,,\textit{sztuczna inteligencja}''.
\end{description}

\column{0.5\textwidth}
\begin{figure}
\includegraphics[scale=1.2]{images/mccarthy.jpg}
\caption{John McCarthy}
\end{figure}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Symbole}
\pause
Okazuje się, że operowanie na \textbf{symbolach} jest istotne przy 
tworzeniu sztucznej inteligencji. \pause

\n Ludzkie rozumowanie opiera się na manipulacji symbolami (\textit{physical symbol system hypothesis} -- Allan Newell i Herbert A. Simon)\pause

\n System symboli składa się z symboli, składania ich w struktury (wyrażenia) i manipulowania nimi (przetwarzania) w celu tworzenia nowych wyrażeń.

\end{frame}


\begin{frame}
\frametitle{Symbole}

W 1959 roku John McCarthy pisze pracę ,,\textit{Programs with common sense}''
zainspirowaną programem ,,Logic Theorist''.
\pause

\n Proponuje w niej stworzenie programu ,,\textit{Advice Taker}'', który rozwiązywałby problemy poprzez manipulację zdaniami (\textbf{symbole!}).
\pause

\n ,,\textit{Our ultimate objective is to make programs that 
              learn from their experience as effectively
              as humans do.}''
\end{frame}



\begin{frame}
\frametitle{,,\textit{Programs with common sense}''}
\pause
,,\textit{A class of entities called terms
is defined and a term is an expression. A sequence of expressions is an 
expression. These expressions are represented in the machine by list 
structures}'' \pause\,
-- reprezentacja przesłanek/faktów w postaci \textbf{list symboli}
\end{frame}

\begin{frame}
Przykłady:
    $$at(I, desk)$$
    $$at(desk, home)$$
    $$at(car, home)$$
    $$at(home, county)$$
    $$at(airport, county)$$
\pause
    $$at(x, y), at(y,z) \rightarrow at(x,z)$$
\pause
    $$transitive(at)$$
    $$transitive(u) \rightarrow (u(x,y), u(y,z) \rightarrow u(x,z))$$
\pause
Prawie jak Prolog?
\end{frame}
    


\begin{frame}[fragile]
\frametitle{Zapotrzebowanie na nowe języki}

\begin{columns}
\column{0.6\textwidth}
\textbf{Information Processing Language} \normalsize -- niskopozimowy język 
programowania do manipulowania listami stworzony przez Newella, Shawa i Simona, 
który posłużył do napisania programu. ,,\textit{Logic Theorist}''.
\pause
\n
\begin{itemize}
    \item dane reprezentowane jako listy
    \item procedury operujące na danych
\end{itemize}

\column{0.4\textwidth}
\begin{figure}
\begin{verbatim}
     IPL-V  List 
      Structure 
       Example
    Name SYMB LINK
    L1   9-1  100
    100  S4   101
    101  S5   0
    9-1  0    200
    200  A1   201
    201  V1   202
    202  A2   203
    203  V2   0

\end{verbatim}
\caption{Lista zapisana w IPL-V}
\end{figure}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Information Processing Language}
Nowe feature'y:\pause

\begin{itemize}
    \item Manipulacja listami (tylko listy atomów)\pause
    \item Funkcje wyższego rzędu\pause
    \item Obliczenia na symbolach (tylko litera+liczba)
\end{itemize}

\end{frame}


%==============================================================================%

\section{,,\textit{Recursive Functions of Symbolic Expressions...}''}

\begin{frame}
\frametitle{LISt Processor}
\pause
W 1960 ukazuje się praca Johna McCarthy'ego pt.,,\textit{Recursive Functions of Symbolic Expressions
Their Computation by Machine, Part I}''. \pause
\begin{figure}
\includegraphics[scale=2.3]{images/recursive-functions-1.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Wyrażenia warunkowe}
Po raz pierwszy pojawiła się idea \textit{wyrażeń warunkowych}.
\pause

\begin{figure}
\includegraphics[scale=0.6]{images/conditional.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Wyrażenia warunkowe}

Wyrażenia warunkowe miały mieć następującą postać:
$$(p_1 \rightarrow e_1,\,...\,, p_n \rightarrow e_n)$$

Interpretacja:
\pause
\n ,,Jeżeli $p_1$ to $e_1$, w przeciwnym razie jeżeli $p_2$ to $e_2$, \,...\,, w przeciwnym razie jeżeli $p_n$ to $e_n$''

\end{frame}


\begin{frame}
\frametitle{Wyrażenia warunkowe}
Zasady obliczania wartości wyrażeń warunkowych:
\begin{itemize}
    \item \pause Rozpatruj $p$ od lewej do prawej.
    \item \pause Jeżeli $p$, którego wartość to $T$, występuje przed 
                 jakimkolwiek innym $p$, którego wartość jest niezdefiniowana, 
                 to wartością wyrażenia warunkowego jest wartość 
                 odpowiadającego $e$ (jeżeli jest zdefiniowane).
    \item \pause Jeżeli jakiekolwiek niezdefiniowane $p$ jest napotkane przed 
                 prawdziwym $p$, lub gdy wszystkie $p$ są fałszywe, bądź gdy 
                 $e$ odpowiadającego pierwszemu prawdziwemu $p$ jest 
                 niezdefiniowane, to wartość wyrażenia jest niezdefiniowana.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Wyrażenia warunkowe}
Przykłady:\pause

$$(2 < 1 \rightarrow 4, T \rightarrow 3) = \pause 3$$\pause
$$(2 < 1 \rightarrow \frac{0}{0}, T \rightarrow 3) = \pause 3$$\pause
$$(2 < 1 \rightarrow 3, T \rightarrow \frac{0}{0}) = \pause undefined$$\pause
$$(2 < 1 \rightarrow 3, 4 < 1 \rightarrow 1) = \pause undefined$$
\end{frame}


\begin{frame}
\frametitle{Wyrażenia warunkowe}

Wyrażenia warunkowe pozwalają na eleganckie zapisywanie funkcji:
\pause
$$|x| = (x < 0 \rightarrow -x, T \rightarrow x)$$
\pause
$$sgn(x) = (x < 0 \rightarrow -1, x = 0 \rightarrow 0, T \rightarrow 1)$$
\pause

W ,,\textit{History of Lisp}'' McCarthy narzekał na niewygodne instrukcje 
warunkowe w FORTRANie. \pause Naturalnym było wynalezienie funkcji 
\texttt{XIF(M,N1,N2)}, która zwracała \texttt{N1} lub \texttt{N2} zależnie od 
wartości \texttt{M}, ale FORTRAN miał ewaluację gorliwą.

\end{frame}


\begin{frame}
\frametitle{Funkcje rekurencyjne}

Zapis funkcji rekurencyjnych przy użyciu wyrażeń warunkowych:
$$n! = (n = 0 \rightarrow 1, T \rightarrow n \cdot (n - 1)!)$$
\pause
\begin{equation*}
\begin{gathered}
    gcd(m ,n) = (m > n \rightarrow gcd(n,m), \\
                rem(n,m) = 0\rightarrow m, \\
                T \rightarrow gcd(rem(n,m), m))
\end{gathered}
\end{equation*}
\end{frame}


\begin{frame}
\frametitle{Funkcje rekurencyjne}
\begin{figure}
\includegraphics[scale=2.20]{images/infinite-recursion.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Spójniki logiczne}
\pause
$$p \wedge q = (p \rightarrow q, T \rightarrow F)$$\pause
$$p \vee q = (p \rightarrow T, T \rightarrow q)$$\pause
$$ \sim{p} = (p \rightarrow F, T \rightarrow T)$$\pause
$$p \Rightarrow q = (p \rightarrow q, T \rightarrow T)$$
\end{frame}


\begin{frame}
\frametitle{Spójniki logiczne}
\begin{figure}
\includegraphics[scale=2.1]{images/lazy.png}
\caption{Ewaluacja leniwa?}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Spójniki logiczne -- leniwa ewaluacja}
$$ p \wedge q = (p \rightarrow q, T \rightarrow F)$$
Argumenty funkcji ,,$\wedge$'' nie są poddawane ewaluacji przed jej aplikacją.
\end{frame}


\begin{frame}
\frametitle{Formy a funkcje}
\pause
Pojęcie formy zostało zapożyczone z rachunku lambda Churcha.

\pause
\n $y^2 + x$ -- forma


\pause
$(y^2 + x)(3,4)$ -- źle. Nie wiadomo czy wartością powinno być 13 czy 19.

\pause
\n Formę $\mathcal{E}$ możemy skonwertować na funkcję jeżeli ustalimy powiązanie między zmiennymi w formie a uporządkowaną listą argumentów funkcji:

\pause
\n $\lambda((x_1,\,...\,,x_n), \mathcal{E}))$ -- funkcja


\pause
$\lambda((x, y), y^2 + x)$ -- też funkcja
\end{frame}


\begin{frame}
\frametitle{Rekurencyjne $\lambda$-wyrażenia}
\pause

\begin{equation*}
    \begin{gathered}
    sqrt = \lambda((a,x,\epsilon),\\
        (|x^2 - a| < \epsilon \rightarrow x, 
        T \rightarrow sqrt(a, \frac{1}{2}(x + \frac{a}{x}), \epsilon)))
    \end{gathered}
\end{equation*}

\pause
Prawa strona wyrażenia nie może być wyrażeniem dla tej funkcji, bo nic nie wskazuje na to, że $sqrt$ do odnosi się do całego wyrażenia ($sqrt$ nie jest związane).


\pause
\n Operator punktu stałego? \pause-- zbyt długie i nieczytelne wyrażenia.

\end{frame}


\begin{frame}
\frametitle{Rekurencyjne $\lambda$-wyrażenia}

Nowa notacja:
\pause

$$label(a, \mathcal{E})$$
\pause

Wyrażenie $\mathcal{E}$, w którym wszystkie wystąpienia $a$ interpretowane są jako odniesienia do całego wyrażenia $\mathcal{E}$.
\end{frame}


\begin{frame}
\frametitle{S-wyrażenia}
\pause

,,\textit{A Class of Symbolic Expressions}''.
\pause

\n Dopuszczalne znaki:
\begin{itemize}
    \item $.$ \pause
    \item $)$ \pause
    \item $($ \pause
    \item Nieskończony zbiór rozróżnialnych symboli atomowych -- napisów złożonych z wielkich liter alfabetu łacińskiego, cyfr i pojedynczych spacji.
    \pause\n Na przykład:
        \begin{itemize}
            \item A
            \item ABA
            \item APPLE PIE NUMBER 3
        \end{itemize}
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{S-wyrażenia}
Czemu symbole składające się z wielu znaków?\pause

\n Odpowiedź:
\begin{itemize}
    \item IBM 704 miał tylko 47 drukowalnych znaków więc jednoliterowe symbole 
    byłyby niewystarczające\pause
    \item Nazywanie atomowych bytów angielskimi słowami i zdaniami jest wygodne

\end{itemize}
\end{frame}


\begin{frame}
\frametitle{S-wyrażenia}

Definicja indukcyjna S-wyrażeń:

\begin{enumerate}
    \item\pause Symbole atomowe są S-wyrażeniami
    \item\pause Jeżeli $e_1$ i $e_2$ są S-wyrażeniami, to $(e_1 \cdot e_2)$ 
                również jest S-wyrażeniem.
\end{enumerate}

\pause \n Przykładowe S-wyrażenia:
$$AB$$
$$(A \cdot B)$$
$$((AB \cdot C) \cdot D)$$
\end{frame}


\begin{frame}
\frametitle{Listy (S-wyrażenia)}

Możemy reprezentować listy dowolnej długości przy użyciu S-wyrażeń w następujący sposób:

\pause \n
$(m_1, m_2, \,...\, m_n) = (m_1 \cdot (m_2 \cdot (...(m_n \cdot NIL)...)))$
\pause

Gdzie NIL jest specjalnym symbolem kończącym listy.

\pause \n
Wprowadzamy zatem specjalną notację dla list:\pause
\begin{enumerate}
    \item $(m) = (m \cdot NIL)$
    \item $(m_1, m_2, \,...\, m_n) = 
           (m_1 \cdot (...(m_n \cdot NIL)...))$
    \item $(m_1, \,...\, ,m_n \cdot x) = (m_1 \cdot (...(m_n \cdot x)...))$
\end{enumerate}
\end{frame}


\begin{frame}
\frametitle{M-wyrażenia}
\pause
Aby odróżnić wyrażenia reprezentujące aplikację funkcji od S-wyrażeń, będziemy małych liter do nazywania funkcji i zmiennych.


\pause \n
Będziemy również używać nawiasów kwadratowych i średników zamiast nawiasów i przecinków.

\pause
Na przykład:
$$car[x]$$
$$car[cons[(A \cdot B); x]]$$

\pause \n
M-wyrażenia -- meta-wyrażenia
\end{frame}


\begin{frame}
\frametitle{Funkcje i predykaty dla S-wyrażeń}
\pause
\begin{description}
    \item $atom[x]$ -- prawda tylko jeżeli $x$ jest symbolem
    \item $eq[x;y]$ -- prawda tylko jeżeli $x$ i $y$ są tym samym symbolem
    \item $car[x]$ -- zdefiniowany tylko jeżeli $x$ nie jest symbolem.\pause
        \begin{description}
            \item $car[(X\cdot A)] = X$
            \item $car[((X \cdot A) \cdot Y)] = (X \cdot A)$
        \end{description}
    \item \pause $cdr[x]$ -- zdefiniowany tylko jeżeli $x$ nie jest 
                             symbolem \pause
        \begin{description}
            \item $cdr[(X \cdot A)] = A$
            \item $cdr[((X \cdot A) \cdot Y)] = Y$
        \end{description}
    \item \pause $cons[x;y] = (e_1 \cdot e_2)$
\end{description}
\end{frame}


\begin{frame}
\frametitle{Funkcje i predykaty dla S-wyrażeń}
    Widać, że $car, cdr$ i $cons$ spełniają poniższe zależności: \pause
    \begin{description}
        \item $car[cons[x;y]] = x$
        \item $cdr[cons[x;y]] = y$
        \item $cons[car[x]; cdr[x]] = x$ (pod warunkiem, że $x$ nie jest 
              atomowe)
    \end{description}
\end{frame}


\begin{frame}
\frametitle{Funkcje i predykaty dla S-wyrażeń}

Dalej McCarthy opisuje różne funkcje, które można zapisać przy użyciu wcześniej opisanej notacji.
    \begin{itemize}
        \item $append[x;y]$\pause
        \item $among[x;y]$ \pause-- czy $y$ zawiera $x$?\pause
        \item $pair[x;y]$ \pause -- \texttt{zip}\pause
        \item $assoc[x;y]$ \pause -- szukanie wartości dla klucza 
            $x$ na liście par $y$\pause
        \item $sublis[x;y]$ \pause-- mamy listę symboli $y$, pod które chcemy 
        podstawić przypisane im wartości z listy asocjacji $x$ \pause
    \end{itemize}
\end{frame}


\begin{frame}
\frametitle{Tłumaczenie M-wyrażeń na S-wyrażenia}

Chcemy przetłumaczyć M-wyrażenie $\mathcal{E}$ na S-wyrażenie $\mathcal{E}^*$
\pause

\begin{enumerate}
    \item Jeżeli $\mathcal{E}$ jest S-wyrażeniem, to $\mathcal{E}^* = (QUOTE, 
          \mathcal{E})$ \pause
    \item Zmienne i nazwy funkcji napisane małymi literami zamieniamy na 
          odpowiadające napisy złożone z wielkich liter (np. $car^* = CAR$).
          \pause
    \item $\{f[e_1 ; \,...\,;e_n]\}^* = (f^*, e_1^*, \,...\,,e_n^*)$ \pause
    \item $\{[p_1 \rightarrow e_1; \,...\,; p_n \rightarrow e_n]\}^* =
          (COND, (p_1^*, e_1^*), \,...\, (p_n^*, e_n^*))$ \pause
    \item $\{[\lambda[[x_1;\,...\,;x_n]; \mathcal{E}]]\}^* =
          (LAMBDA, (x_1^*, \,...\,, x_n^*), \mathcal{E}^*)$ \pause
    \item ${label[a;\mathcal{E}]}^* = (LABEL, a^*, \mathcal{E}^*)$
\end{enumerate}
\end{frame}


\begin{frame}
\frametitle{S-wyrażenia}
\begin{figure}
\includegraphics[scale=0.6]{images/readable1.png}\pause\n
\includegraphics[scale=0.6]{images/readable2.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{$apply$}

Funkcja $apply$ aplikuje S-wyrażenie $f$ reprezentujące S-funkcję $f'$ do listy argumentów $args$ postaci $(arg_1,\,...\,arg_n)$.\pause

$$apply [f;args] = eval [cons [f; appq [args]]; NIL]$$ \n gdzie \n

\begin{equation*}
    \begin{gathered}    
    appq[m] = \\
    [null[m] \rightarrow NIL; \\
    T \rightarrow cons [list [QUOTE; car [m]]; appq [cdr [m]]]]
    \end{gathered}
\end{equation*}
\end{frame}


\begin{frame}
\frametitle{$eval$}

\begin{description}
    \item $eval[e;a] = [$ \pause
    \item \quad $atom[e] \rightarrow assoc[e; a]$ \pause
    \item \quad $atom[car[e]] \rightarrow [$ \pause
    \item \quad\quad $eq[car[e]; QUOTE] \rightarrow cadr[e];$ \pause
    \item \quad\quad $eq[car[e]; ATOM] \rightarrow atom[eval[cadr[e];a]];$\pause
    \item \quad\quad $eq[car[e]; EQ]
                      \rightarrow eval[cadr [e];a]=eval[caddr[e];a];$\pause
    \item \quad\quad $eq[car[e]; COND] \rightarrow evcon[cdr [e]; a];$\pause
    \item \quad\quad $eq[car [e]; CAR] \rightarrow car[eval[cadr[e];a]];$\pause
    \item \quad\quad $eq[car [e]; CDR] \rightarrow cdr[eval[cadr[e];a]];$\pause
    \item \quad\quad $eq[car[e];CONS] \rightarrow $ \n
          \quad\quad\quad$cons[eval[cadr[e];a];eval[caddr[e];a]];$\pause
    \item \quad\quad $T\rightarrow eval[cons [assoc[car [e];a]; evlis[cdr [e];a]
                    ];a]];$
\end{description}
\end{frame}


\begin{frame}
\frametitle{$eval$ cd.}
\begin{description}
    \item \quad $eq [caar [e]; LABEL] \rightarrow$ \n
          \quad\quad $eval [cons[caddar [e]; cdr [e]];$ \n 
          \quad\quad $cons[list [cadar [e]; car[e]; a]];$\pause
    \item \quad $eq [caar [e]; LAMBDA] \rightarrow$ \n
          \quad\quad $eval[caddar [e]; append[pair[cadar[e]; evlis[cdr [e]; a]; a]]$ 
    \item $]$\pause
\end{description}

gdzie

$evcon[e;a] = [eval [caar [e];a] \rightarrow eval [cadar [e]; a];  T \rightarrow evcon[cdr[e];a]]$

\n

$evlis[m;a] = [null [m] \rightarrow NIL; T \rightarrow cons[eval[car[m];a];evlis[cdr[m];a]]]$
\end{frame}


\begin{frame}
\frametitle{Funkcje wyższego rzędu}
\pause

\begin{figure}
\includegraphics[scale=2.3]{images/higher-order-functions.png}
\end{figure}
\pause

\begin{description}
    \item $maplist[x;f] = [$
    \item \quad $null[x] \rightarrow NIL;$
    \item \quad $T \rightarrow cons[f[x]; maplist[cdr [x]; f]]]$
\end{description}
\pause\n
\begin{description}
    \item $search[x;p;f;u] = [$
    \item \quad $null [x] \rightarrow u;$
    \item \quad $p[x] \rightarrow f[x]$;
    \item \quad $T \rightarrow search [cdr [x]; p; f; u]]$
\end{description}
\end{frame}


\begin{frame}
\begin{figure}
\includegraphics[scale=0.6]{images/diff.png}
\caption{Funkcja obliczająca pochodne funkcji zaaplikowana do wyrażenia $
         (TIMES, X, (PLUS, X, A), Y)$}
\end{figure}
\end{frame}

%==============================================================================%
\section{Pierwsze implementacje}

\begin{frame}
\frametitle{Reprezentacja S-wyrażeń w pamięci}
\pause
\begin{figure}
\includegraphics[scale=0.4]{images/list-layout-a.png}
\end{figure}
Lista jest zbiorem słów maszynowych połączonych wskaźnikami w jedną strukturę.
Każde słowo na rysunku jest reprezentowane jako jeden z podzielonych na pół prostokątów.
\pause

\n
Słowo maszynowe w IBM 704 dzieli się na dwa pola: lewe $address$ oraz prawe 
$decrement$ i 6 pozostałych bitów.
\pause
\end{frame}


\begin{frame}
\frametitle{Reprezentacja S-wyrażeń w pamięci}
\begin{columns}
\column{0.5\textwidth}
\begin{figure}
\includegraphics[scale=2.0]{images/list-layout-b.png}
\end{figure}
Jedna podstruktura może pojawiać się więcej niż w jednym miejscu w strukturze...
\pause
\column{0.5\textwidth}
\begin{figure}
\includegraphics[scale=2.0]{images/list-layout-c.png}
\end{figure}
...ale struktury nie mogą zawierać cyklów.
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Reprezentacja S-wyrażeń cd.}
\begin{figure}
\includegraphics[scale=2.3]{images/list-layout-circular.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Reprezentacja S-wyrażeń cd.}

Benefity wynikające z używania list:\pause

\begin{itemize}
    \item Ani rozmiar, ani liczba wyrażeń w programie nie może być przewidziana 
    wcześniej, więc ciężko byłoby zaaranżować bloki pamięci o stałym rozmiarze.
    \pause
    \item Rejestry można odkładać na listę dostępnej pamięci gdy nie są już 
    potrzebne. Nawet jeden wolny rejestr jest wartościowy w przeciwieństwie do 
    sytuacji gdzie wyrażenia są przechowywane liniowo w ciągłych obszarach 
    pamięci.\pause
    \item Wyrażenie, które jest podwyrażeniem wielu wyrażeń, może być dzielone 
    i przechowywane jedynie raz.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Listy asocjacji}
\begin{itemize}
    \item \pause Każdy symbol może posiadać listę dowolnych dodatkowych 
                 informacji z nim powiązanych.
        \begin{itemize}
            \item \pause \textit{print name} -- napis reprezentujący symbol na 
            zewnątrz maszyny
            \item \pause numeryczna wartość dla symboli, które są liczbami
            \item \pause inne S-wyrażenie
            \item \pause adres procedury dla symboli, które są nazwami dla 
                         funkcji zaimplementowanych w kodzie maszynowym
        \end{itemize}
\end{itemize}
\pause \n
\begin{columns}
\column{0.4\textwidth}
\textit{Print names} są reprezentowane jako listy słów zawierających 
maksymalnie sześć 6-bitowych znaków. Ostatnie słowo dopełnione jest wartościami,
które nie reprezentują drukowalnych znaków.
\column{0.6\textwidth}
\begin{figure}
\includegraphics[scale=1.4]{images/pname.png}
\caption{\textit{pname} dla symbolu DIFFERENTIATE}
\end{figure}
\end{columns}
\end{frame}


\begin{frame}
    \frametitle{IBM 704}
    \pause
    Kilka faktów o IBM 704:\n
    \begin{itemize}
        \item \pause 36-bitowe słowa
        \item \pause 15-bitowa przestrzeń adresowa
        \item \pause 38-bitowy akumulator
        \item \pause 36-bitowy rejestr \textit{multiplier quotient}
        \item \pause Trzy 15-bitowe rejestry \textit{index}
        \item \pause Instrukcje miały dwa typy: \pause
            \begin{description}
                \item[B] -- nieciekawe \pause
                \item[A] -- każda instrukcja typu A składa się z: \pause
                    \begin{itemize}
                        \item 3-bitowy prefiks (kod instrukcji) \pause
                        \item 15-bitowe pole \textit{decrement} (niektóre 
                        instrukcje odejmują tę wartość od wartości w rejestrze) 
                        \pause
                        \item 3-bitowe pole \textit{tag} (wskazuje rejestr) \pause
                        \item 15-bitowe pole \textit{address}
                    \end{itemize}
            \end{description}
\end{itemize}
\end{frame}    


\begin{frame}
\frametitle{\textit{Free-Storage List}}
\pause
Specjalny rejestr FREE zawiera adres pierwszego słowa listy 
\textit{free storage}.

\pause \n
Jak przebiega alokacja pamięci?
\pause
\begin{enumerate}
    \item Weź pierwsze wolne słowo z listy
    \item \pause Ustaw wartość rejestru FREE na adres drugiego słowa z listy
\end{enumerate}
\end{frame}


\begin{frame}
\frametitle{\textit{Free-Storage List}}
Istnieje ustalony zbiór bazowych rejestrów, które 
zawierają adresy struktur listowych, do których istnieje dostęp w programie.

\n
\pause Każdy rejestr, który jest osiągalny przez program, jest osiągalny z 
jednego lub więcej bazowych rejestrów poprzez łańcuch operacji 
\textit{car} i \textit{cdr}.

\n
\pause Zmiana zawartości jednego z bazowych rejestrów może spowodować, że wskazywany dotychczas rejestr staje się nieosiągalny. Oznacza to wówczas, że jego zawartość nie jest już potrzebna.

\n
\pause Nie jest podejmowane żadne działanie w celu zwalniania pamięci, dopóki 
programowi nie skończy się cała wolna pamięć. Gdy potrzebny jest wolny rejestr, rozpoczyna się \textit{reclamation cycle}.
\end{frame}


\begin{frame}
\frametitle{\textit{Garbage collector}\only<3,4>{\,\,\,(mark-and-sweep)}}
\begin{enumerate}
    \item \pause Znajdujemy wszystkie słowa osiągalne z rejestrów 
    bazowych i ustawiamy ich znak na ujemny.
    \item \pause Przeszukujemy obszar pamięci zarezerwowany dla struktur 
    listowych i dodajemy wszystkie słowa o znaku dodatnim do listy 
    \textit{free-storage}.
\end{enumerate}
\pause \n \n
Implementacja odśmiecania pamięci przez zliczanie referencji nie była praktyczna, bo dostępne było jedynie 6 bitów na każde słowo.

\end{frame}


\begin{frame}
\frametitle{Implementacja wbudowanych funkcji}

\pause
\begin{description}
    \item[atom] -- słowo reprezentujące symbol ma specjalną stałą w części 
                   adresowej.\pause
    \item[eq] -- numeryczna równość adresów słów. Dla symboli działa to dlatego,
                 że każdy symbol ma tylko jedną listę asocjacji.\pause
    \item[cons] -- wartością $cons[x;y]$ musi być adres rejestru, który ma 
    adres $x$ jako część $address$ i $y$ jako część $decrement$. \n 
    \textit{Cons} zawsze bierze nowe słowo z listy \textit{free-storage}.
    Wywołanie \textit{cons} może uruchomić garbage collectora.
\end{description}
\end{frame}


\begin{frame}[fragile]
\frametitle{car i cdr}

IBM 704 miał specjalne instrukcje do oczytywania pól 
\textit{address} i \textit{decrement} słowa. Pozwalało to na wydajne 
przechowywanie dwóch 15-bitowych wskaźników w jednym słowie.
\pause \n \n

Makra \texttt{car} i \texttt{cdr} w assemblerze 704:
\begin{columns}
\column{0.7\textwidth}
\begin{verbatim}
# car:
CLA 0, i # wyczyść AC i dodaj i
PAX 0, i # zapisz Address AC do i
PXD 0, i # wyczyść AC i wczytaj 
         # i do Decrement AC
\end{verbatim}
\column{0.3\textwidth}
\begin{verbatim}
# cdr:
CLA 0, i
PDX 0, i
PXD 0, i
\end{verbatim}
\end{columns}


\n \n
\begin{description}
    \item[car] -- ,,\textbf{C}ontents of the 
                    \textbf{A}ddress \textbf{R}egister''
    \item[cdr] -- ,,\textbf{C}ontents of the 
                    \textbf{D}ecrement \textbf{R}egister''
\end{description}
\n
\end{frame}


\begin{frame}
\frametitle{car i cdr}

,,\textit{Because of an unfortunate temporary lapse of inspiration, we couldn't think of any other names for the 2 pointers in a list node than 'address' and 'decrement', so we called the functions CAR for 'Contents of Address of Register' and CDR for 'Contents of Decrement of Register'.}


\textit{After several months and giving a few classes in LISP, we realized that 'first' and 'rest' were better names, and we (John McCarthy, I and some of the rest of the AI Project) tried to get people to use them instead.}


\textit{Alas, it was too late! We couldn't make it stick at all. So we have CAR and CDR.}''
\rightline{--- Steve Russell}
\end{frame}



\begin{frame}
\frametitle{Steve Russell}

\pause

,,\textit{S.R. Russell noticed that eval could serve as an interpreter for LISP,
promptly hand coded it, and we now had a programming language with an
interpreter.}''
\rightline{--- John McCarthy}

\pause
\begin{columns}
\column{0.3\textwidth}
\includegraphics[scale=0.55]{images/russell.jpg}
\column{0.7\textwidth}
\begin{itemize}
    \item Napisał pierwszy interpreter LISPu \pause
    \item W 1962 zaprojektował i napisał grę ,,\textit{Spacewar!}''
        \begin{figure}
            \includegraphics[scale=0.14]{images/spacewar.jpg}
        \end{figure}
\end{itemize}
\begin{figure}
\end{figure}
\end{columns}

\end{frame}


\begin{frame}
\frametitle{Wiązanie dynamiczne zmiennych}
To, że LISP używa wiązania dynamicznego zmiennych wyszło na jaw (przypadkiem),
gdy James R. Slagle napisał poniższą funkcję, i okazało się, że nie działa:
\n\n\pause
\begin{description}
    \item $testr[x,p,f,u] \leftarrow$ \textbf{if} $p[x]$ \textbf{then} $f[x]$
    \item \quad \quad \textbf{else if} $atom[x]$ \textbf{then} $u[]$
    \item \quad \quad \textbf{else} $testr[cdr[x], p,f,\lambda : $
                \only<2>{$testr[car[x],p,f,u]]$}
                \only<3>{$testr[$\underline{$car[x]$}$,p,f,u]]$}
\end{description}
\pause\n
Wbrew oczekiwaniom, wartość $car[x]$ z budowanej kontynuacji $u$ nie pochodziła 
z zewnętrznego wywołania rekurencyjnego, ale z wewnętrznego, gdzie funkcja $u$ 
została wywołana.
\end{frame}


\begin{frame}
\frametitle{Wiązanie dynamiczne zmiennych}
McCarthy powyższe zachowanie uznał za błąd i liczył na to, że Steve Rusell go naprawi.

\n
\pause
Rozwiązanie: \pause ,,FUNARG device'' -- przekazywanie lokalnego środowiska razem z funkcją.

\n \n \n 
\pause
Wniosek? \pause Wiązanie dynamiczne to bug a nie feature.
\end{frame}


\begin{frame}
\frametitle{Co po LISPie 1 i 1.5?}
\begin{description}
    \item[LISP 2] -- język łączący semantykę LISPu i składnię Algola. Tworzony
                     wspólnie przez Systems Development Corporation (pierwsza 
                     firma wytwarzająca oprogramowanie) i Information International Inc. Planowano implementację na komputer Q32
                     budowany przez IBM dla celów wojskowych (48-bitowe słowa i 18-bitowe adresy). \pause\n
                     Gdy okazało się, że Q32 wyposażony będzie w nie więcej niż 48K słów pamięci, zdecydowano się zaimplementować język na komputery IBM 360/67 i PDP-6. \pause\n
                     W związku z m.in. wysokimi kosztami projekt został porzucony.
\end{description}
\end{frame}

\begin{frame}
\frametitle{Co po LISPie 1 i 1.5?}
\begin{description}
    \item[MacLisp] \pause -- rozwijany na MIT. Nazwa pochodzi od Projektu MAC.
        \begin{itemize}
            \item \pause Wprowadzono ,,\textit{value cell}'' w celu 
                przyspieszenia dostępu do zmiennych (w oryginalnym LISPie 
                przeszukiwano liniowo listę asocjacji)
            \item \pause \texttt{DEFMACRO}
            \item \pause \texttt{LEXPR} -- funkcje przyjmujące dowolną 
                liczbę argumentów przekazywanych przez stos
            \item \pause \texttt{ERRSET} -- funkcja pełniąca rolę \texttt{try} 
                (w 1972 wprowadzono \texttt{TRY} i \texttt{CATCH})
            \item \pause Bignumy
        \end{itemize}
\end{description}
\end{frame}


\begin{frame}
\frametitle{Co po LISPie 1 i 1.5?}
\begin{description}
    \item[InterLisp] \pause -- tworzony przez BBN Technologies na PDP-10\pause 
        \begin{itemize}
            \item   Wiele narzędzi programistycznych \pause
                \begin{itemize}
                    \item \textit{spelling corrector} \pause
                    \item ,,\textit{Do what I mean}''\pause
                    \item Masterscope -- narzędzie do wyszukiwania informacji 
                    (np. która funkcja wywołuje którą) o funkcjach w dużych 
                    systemach. \pause
                \end{itemize}
            \item Supernawiasy (nawias kwadratowy zamykał wszystkie otwarte 
                nawiasy) \pause
            \item ,,\textit{spaghetti stacks}''
        \end{itemize}
\end{description}
\end{frame}

\begin{frame}
    \frametitle{Co po LISPie 1 i 1.5?}
    \begin{description}
        \item[Scheme] \pause -- stworzony przez Geralda J. Sussmana i Guya 
        Steele'a
            \begin{itemize}
                \item Statyczne wiązanie zmiennych
                \item Wymóg optymalizacji wywołań ogonowych
                \item Jeden z pierwszych języków wspierający 
                    \textit{first-class continuations}
            \end{itemize}
    \end{description}
    \end{frame}

%==============================================================================%

\section{Być może coś więcej}
\begin{frame}
\frametitle{Lisp-maszyny}

\pause
\textbf{Lisp-maszyna} -- komputer ogólnego przeznaczenia zaprojektowane do efektywnego wykonywania Lispu przy użyciu sprzetowego wsparcia.

\pause
\begin{columns}
\column{0.3\textwidth}
\begin{figure}
    \includegraphics[scale=0.3]{images/lisp-machine-3640.jpeg}
\end{figure}
\column{0.7\textwidth}
\pause

W 1973 roku Richard Greenblatt i Thomas Knight z MIT rozpoczęli budowę komputera, który miałby wsparcie sprzętowe dla wykonywania Lispowych operacji.

\pause
Cele:
\begin{itemize}
    \item Sprzętowo wspomagane sprawdzanie typów \pause
    \item Sprzętowy garbage collector
    \item Jeden użytkownik \pause
    \item Niska cena (mniej niż \$70,000 za sztukę)
\end{itemize}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}
\begin{description}
    \item[CONS] -- pierwsza Lisp-maszyna zbudowana na MIT \pause
    \item[CADR] -- ulepszona wersja CONSa \pause
        \begin{itemize}
            \item Została bardzo dobrze przyjęta\pause
            \item Sprzedano około 25 (prototypowych) egzamplarzy\pause
            \item DARPA (Defense Advanced Research Projects Agency) zaczęła 
                  sponsorować jej rozwój
        \end{itemize}
\end{description}
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}
W 1979 Russell Noftsker przekonany o nieuniknionym sukcesie komercyjnym 
Lisp-maszyn zaproponował Greenblattowi skomercjalizowanie tej technologii. 
Niezgoda doprowadziła jednak do powstania dwóch oddzielnych firm: Lisp Machines 
Incorporated (LMI) oraz Symbolics.
\n\n
\pause Na początku obydwie firmy produkowały klony maszyny CADR ale wkrótce 
Symbolics wprowadziło linię 3600, która stała się liderem wydajności wśród 
Lisp-maszyn na najbliższe 5 lat.
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}

\begin{figure}
    \includegraphics[scale=0.175]{images/space-caded.jpg}
\caption{Klawiature ,,space-cadet'' firmy Symbolics}
\end{figure}
    
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}
Mimo tego, że Greenblattowi zależało na sprzętowym mechanizmie odśmiecania 
pamięci, to wczesne Lisp-maszyny MIT nie implementowały garbage collectora.

\n \n
\pause
Po pojawieniu się garbage collectora, użytkownicy i tak go wyłączali. Większość narzędzi programistycznych zaprojektowanych było tak, by unikać 
alokacji pamięci
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}

Dialekt Lispu używany przez wczesne Lisp-maszyny z MIT (Lisp Machine Lisp) był 
bardzo podobny do MacLispu, ale miał kilka istotnych rozszerzeń:\pause
\begin{itemize}
    \item narzędzia programistyczne zbliżone bardziej do tego 
        co oferował Interlisp \pause
    \item specyfikatory argumentów lambd takie jak 
        \texttt{\&optional, \&key, \&rest} i \texttt{\&aux}\pause
    \item ,,\textit{locatives}'' (wskaźniki na wnętrza obiektów)\pause
    \item \textit{backquote}'y (np. \texttt{`(1 ,(+ 1 1) 3)})\pause
    \item ,,\textit{Stack groups}'' -- obiekty reprezentujące obliczenia i ich 
        wewnętrzny stan\pause
    \item możliwość zwracania wielu wartości z funkcji bez konstruowania 
        listy\pause
    \item \texttt{DEFSTRUCT} do tworzenia rekordów/struktur\pause
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Lisp-maszyny}
\begin{itemize}
    \item domknięcia (wymagające podania zmiennych, które powinne 
    przechwycić domknięcie)\pause
    \item Flavors -- system programowania obiektowego\pause
    \item \texttt{SETF}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Lisp-maszyny}

BBN Technologies pracowało nad swoją własną Lisp-maszyną o nazwie Jericho, ktora miała użyć Interlispu. Nie została jednak nigdy wprowadzona na rynek, więc grupa zajmująca AI odeszła i w większości została zatrudniona przez Xerox.

\pause\n\n
Środowisko Interlispu zostało zaimplementowane na mikrokodowalnej maszynie Xerox Alto ale była ona zbyt słaba. Port na Xerox Dorado byłby bardzo dobrą Lisp-maszyną, gdyby komputer ten był szerzej dostępny.

\pause\n\n
Wszystkie Lisp-maszyny Xerox używały zliczania referencji w implementacji 
garbage collectora.
\end{frame}


\begin{frame}
\frametitle{Kodowanie CDR}
\pause
Często listy tworzone są w całości. Można wówczas zaoszczędzić miejsce w 
pamięci i zwiększyć lokalność przestrzenną zamieniając referencje na faktyczne 
wartości.
\pause\n\n
Przykład: chcemy utworzyć listę \texttt{'(1 2 3 4)}.
\pause\n\n
Normalnie w pamięci wyglądałaby tak:
\begin{figure}
\includegraphics[]{images/normal-list.png}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Kodowanie CDR}
Jeżeli mamy do dyspozycji dodatkowe nieużywane bity w każdym słowie, to możemy 
dla każdego słowa przechowywać informację o tym, jakiego jest rodzaju:
\pause
\begin{description}
    \item[CDR-NORMAL] -- komórka jest pierwszą połową zwykłej pary\pause
    \item[CDR-NEXT] -- następna komórka jest \textit{CAR}em komórki, na którą 
    normalnie wskazywałby niejawny \textit{CDR}\pause
    \item[CDR-NULL] -- ostatnia komórka na liście
\end{description}
\pause
\begin{figure}
    \includegraphics[scale=0.5]{images/list-cdr.png}
    \caption{Reprezentacja skompresowanej listy \texttt{'(1 2 3 4)}}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Kodowanie CDR}
Wady?\pause
\begin{itemize}
    \item W przypadku występowania mutowalnych par, modyfikacja \textit{CAR}a 
    wymaga kopiowania części obiektu.
\end{itemize}
\end{frame}


\end{document}
