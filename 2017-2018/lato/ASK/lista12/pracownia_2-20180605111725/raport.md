# Pracownia #2 – sprawozdanie
#### Autor: Jakub Grobelny
#### Numer indeksu: 300481

---
Konfiguracja:
---
Informacje o systemie:
     
    - Dystrybucja: Ubuntu 17.10
    - Jądro:       Linux 4.13
    - Kompilator:  GCC 7.2.0
    - Procesor:    Intel® Core™ i5-4570 @ 4 x 3.6GHz

Pamięć podręczna:

    - L1d: 256KiB, 8-drożny, rozmiar linii 64B
    - L2: 1024KiB, 8-drożny, rozmiar linii 64B
    - L3: 6144KiB, 12-drożny, rozmiar linii 64B

Pamięć TLB:

    - L1d: 4KiB strony, 4-drożny, 64 wpisy
    - L2:  4KiB strony, 8-drożny, 1024 wpisy

---
Uwagi:
---

    - W folderze "tests" znajdują się skrypty użyte do wykonania pomiarów
    do zadań.

---
Zadanie 3:
---

Pomysł:

        Podział macierzy na bloki o takich rozmiarach, które mogą pomieścić
    się w całości w pamięci cache i transponowanie tych bloków
    indywidualnie.

Wyniki testów:

    1. Jaki wpływ na wydajność «transpose2» ma rozmiar kafelka?

        Wzrost wydajności jest zależny od wybranego rozmiaru bloku. Najlepsze
    rezultaty zostały osiągnięte przy rozmiarze bloku równym 8. 
    (ponad czterokrotny wzrost wydajności). Wyniki dla wartości 4 i 16 
    były wyraźnie gorsze (odpowiednio około 3 i 2.75 razy mniejszy czas).

    Testy zostały przeprowadzone dla parametru -n równego 4096.

| 8          |            | 4          |            | 16         |            |
|------------|------------|------------|------------|------------|------------|
| transpose1 | transpose2 | transpose1 | transpose2 | transpose1 | transpose2 |
| 0,158424   | 0,04371    | 0,159453   | 0,060081   | 0,169588   | 0,060338   |
| 0,155529   | 0,044247   | 0,160933   | 0,06175    | 0,166653   | 0,060203   |
| 0,157299   | 0,043674   | 0,171673   | 0,058184   | 0,174428   | 0,061519   |
| 0,164121   | 0,044487   | 0,169064   | 0,058461   | 0,166262   | 0,059712   |
| 0,171495   | 0,044142   | 0,173143   | 0,058596   | 0,168446   | 0,060055   |
| 0,16924    | 0,04455    | 0,172155   | 0,058501   | 0,166324   | 0,060469   |
| 0,172786   | 0,041938   | 0,165331   | 0,05822    | 0,165649   | 0,059293   |
| 0,170817   | 0,043223   | 0,18985    | 0,057862   | 0,164826   | 0,06003    |
| 0,172858   | 0,043125   | 0,171266   | 0,058311   | 0,171597   | 0,060722   |
| 0,172633   | 0,043032   | 0,184619   | 0,058858   | 0,171394   | 0,060388   |
| 0,184347   | 0,042998   | 0,191852   | 0,05806    | 0,170079   | 0,059314   |
| 0,18368    | 0,042524   | 0,198323   | 0,059649   | 0,166901   | 0,061151   |
| 0,186016   | 0,043283   | 0,183996   | 0,060536   | 0,173388   | 0,060133   |
| 0,182026   | 0,042928   | 0,187038   | 0,060148   | 0,169457   | 0,063749   |
| 0,192074   | 0,043089   | 0,191865   | 0,059886   | 0,167946   | 0,060244   |
| 0,183012   | 0,043584   | 0,18273    | 0,059379   | 0,16338    | 0,060561   |
| 0,18416    | 0,04298    | 0,181546   | 0,059098   | 0,16661    | 0,060313   |
| 0,186707   | 0,043082   | 0,186517   | 0,060652   | 0,165734   | 0,060225   |
| 0,176035   | 0,04349    | 0,181405   | 0,057873   | 0,164947   | 0,05975    |
| 0,18779    | 0,042425   | 0,183032   | 0,059282   | 0,166963   | 0,05969    |
| 0,18236    | 0,0427     | 0,177818   | 0,055554   | 0,16589    | 0,060292   |
| 0,190848   | 0,041967   | 0,18227    | 0,054603   | 0,173271   | 0,060371   |
| 0,192825   | 0,04278    | 0,181182   | 0,054324   | 0,171619   | 0,063381   |
| 0,186483   | 0,043365   | 0,177314   | 0,055224   | 0,172024   | 0,060315   |
| 0,186158   | 0,042539   | 0,177467   | 0,055044   | 0,172498   | 0,060138   |
| 0,199628   | 0,043056   | 0,175985   | 0,055048   | 0,173918   | 0,060586   |
| 0,188766   | 0,041769   | 0,171157   | 0,055552   | 0,166041   | 0,062451   |
| 0,192298   | 0,042581   | 0,185336   | 0,055733   | 0,165129   | 0,063095   |
| 0,175431   | 0,042335   | 0,182291   | 0,055402   | 0,170425   | 0,061492   |
| 0,188953   | 0,042598   | 0,170776   | 0,059687   | 0,172292   | 0,062555   |
| 0,177857   | 0,042366   | 0,17312    | 0,054377   | 0,179867   | 0,065687   |
| 0,181032   | 0,042831   | 0,175658   | 0,055786   | 0,179111   | 0,064848   |
| 0,181715   | 0,041847   | 0,172963   | 0,055206   | 0,179825   | 0,062951   |
| 0,184058   | 0,042018   | 0,169074   | 0,055053   | 0,167735   | 0,063835   |
| 0,176308   | 0,042513   | 0,175555   | 0,053829   | 0,166262   | 0,063482   |
| 0,174343   | 0,041985   | 0,1791     | 0,054529   | 0,172029   | 0,062814   |
| 0,174294   | 0,042878   | 0,172815   | 0,054471   | 0,171431   | 0,062159   |
| 0,173775   | 0,042509   | 0,171729   | 0,055143   | 0,167276   | 0,06328    |
| 0,170343   | 0,043115   | 0,17949    | 0,054739   | 0,165381   | 0,065874   |
| 0,176099   | 0,041635   | 0,177412   | 0,055829   | 0,16563    | 0,061754   |
| 0,174177   | 0,04286    | 0,175818   | 0,054773   | 0,165549   | 0,06135    |
| 0,176237   | 0,041735   | 0,173519   | 0,054964   | 0,167419   | 0,062255   |
| 0,17481    | 0,043601   | 0,175933   | 0,054408   | 0,166463   | 0,060973   |
| 0,181607   | 0,042155   | 0,179453   | 0,053998   | 0,167198   | 0,06131    |
| 0,182204   | 0,043203   | 0,176067   | 0,054223   | 0,168358   | 0,061625   |
| 0,195175   | 0,044903   | 0,182413   | 0,054107   | 0,165394   | 0,061555   |
| 0,188911   | 0,042826   | 0,180332   | 0,055472   | 0,165649   | 0,06034    |
| 0,177324   | 0,042651   | 0,179589   | 0,054798   | 0,165349   | 0,06074    |
| 0,18339    | 0,043035   | 0,173059   | 0,056157   | 0,165059   | 0,061176   |
| 0,170497   | 0,042098   | 0,173647   | 0,060208   | 0,167901   | 0,060833   |
| 0,170747   | 0,042798   | 0,177452   | 0,059879   | 0,170857   | 0,059157   |
| 0,173771   | 0,042683   | 0,172905   | 0,057578   | 0,164583   | 0,060662   |
| 0,175713   | 0,042632   | 0,173593   | 0,058557   | 0,165759   | 0,060792   |
| 0,172476   | 0,042396   | 0,170392   | 0,057894   | 0,18385    | 0,060535   |
| 0,177572   | 0,041841   | 0,177827   | 0,057817   | 0,179411   | 0,061746   |
| 0,17981    | 0,042798   | 0,178143   | 0,059171   | 0,176086   | 0,061288   |
| 0,183192   | 0,042273   | 0,180697   | 0,058923   | 0,174094   | 0,062148   |
| 0,176304   | 0,043118   | 0,17859    | 0,057347   | 0,175265   | 0,061737   |
| 0,178083   | 0,042109   | 0,176383   | 0,057231   | 0,167048   | 0,064318   |
| 0,174393   | 0,043022   | 0,183807   | 0,057359   | 0,169128   | 0,059898   |
| 0,17337    | 0,042307   | 0,176554   | 0,057614   | 0,165725   | 0,063003   |
| 0,181872   | 0,043173   | 0,181187   | 0,057394   | 0,169129   | 0,060969   |
| 0,172719   | 0,042513   | 0,179031   | 0,056728   | 0,165225   | 0,059537   |
| 0,174566   | 0,042707   | 0,184267   | 0,056661   | 0,164875   | 0,061901   |
| 0,168959   | 0,042112   | 0,172977   | 0,057452   | 0,167636   | 0,061679   |
| 0,173588   | 0,043103   | 0,180066   | 0,056167   | 0,16473    | 0,061771   |
| 0,175517   | 0,04205    | 0,176405   | 0,057147   | 0,171183   | 0,060639   |
| 0,170318   | 0,043091   | 0,181076   | 0,057801   | 0,169208   | 0,060196   |
| 0,170376   | 0,042604   | 0,181868   | 0,055091   | 0,175437   | 0,06292    |
| 0,17498    | 0,043346   | 0,188922   | 0,058481   | 0,168732   | 0,060142   |
| 0,173873   | 0,04396    | 0,173861   | 0,055651   | 0,176306   | 0,064161   |
| 0,175073   | 0,042561   | 0,178891   | 0,058305   | 0,168792   | 0,059497   |
| 0,184883   | 0,042543   | 0,182066   | 0,055005   | 0,164781   | 0,061913   |
| 0,188081   | 0,043948   | 0,180143   | 0,053518   | 0,164285   | 0,059996   |
| 0,184246   | 0,041775   | 0,175232   | 0,05422    | 0,164644   | 0,063059   |
| 0,176157   | 0,04272    | 0,179101   | 0,053608   | 0,164595   | 0,05943    |
| 0,176391   | 0,042127   | 0,176678   | 0,058285   | 0,164456   | 0,062428   |
| 0,179351   | 0,043066   | 0,177744   | 0,054482   | 0,165156   | 0,061473   |
| 0,181632   | 0,041967   | 0,177489   | 0,052178   | 0,168122   | 0,062333   |
| 0,184697   | 0,043006   | 0,186218   | 0,052279   | 0,169044   | 0,05964    |
| 0,179335   | 0,041678   | 0,192387   | 0,055722   | 0,167544   | 0,060895   |
| 0,1798     | 0,043281   | 0,185602   | 0,055365   | 0,168259   | 0,060305   |
| 0,179489   | 0,042961   | 0,18104    | 0,05452    | 0,166274   | 0,060344   |
| 0,174345   | 0,042763   | 0,176924   | 0,056137   | 0,167444   | 0,059729   |
| 0,17871    | 0,041529   | 0,179006   | 0,054021   | 0,166482   | 0,060633   |
| 0,175016   | 0,042885   | 0,183602   | 0,055036   | 0,165533   | 0,060417   |
| 0,178487   | 0,042067   | 0,177884   | 0,059383   | 0,168666   | 0,060513   |
| 0,174163   | 0,042745   | 0,179852   | 0,054308   | 0,166266   | 0,061666   |
| 0,177017   | 0,042662   | 0,182279   | 0,05794    | 0,16837    | 0,060749   |
| 0,181175   | 0,043175   | 0,185301   | 0,053776   | 0,173179   | 0,063092   |
| 0,178208   | 0,041963   | 0,180574   | 0,057427   | 0,173783   | 0,062565   |
| 0,187179   | 0,042921   | 0,176351   | 0,054862   | 0,170837   | 0,062248   |
| 0,189191   | 0,041998   | 0,17898    | 0,054959   | 0,167226   | 0,061172   |
| 0,189653   | 0,042931   | 0,186226   | 0,055649   | 0,167282   | 0,060733   |
| 0,176071   | 0,041474   | 0,192858   | 0,052378   | 0,165838   | 0,061468   |
| 0,195579   | 0,042991   | 0,193579   | 0,056847   | 0,173637   | 0,061217   |
| 0,183531   | 0,041683   | 0,191044   | 0,051802   | 0,165007   | 0,061843   |
| 0,188346   | 0,042544   | 0,186321   | 0,053369   | 0,173007   | 0,05999    |
| 0,186471   | 0,041716   | 0,188344   | 0,052851   | 0,167752   | 0,062062   |
| 0,186806   | 0,043792   | 0,18832    | 0,052028   | 0,172256   | 0,060478   |

| Rozmiar bloku                          | 8          | 16         | 4          |
|----------------------------------------|------------|------------|------------|
| Średni czas transpose1                 | 0,17910237 | 0,17930172 | 0,16895349 |
| Średni czas transpose2                 | 0,04275073 | 0,05639831 | 0,06132463 |
| Różnica                                | 0,13635164 | 0,12290341 | 0,10762886 |
| % dłuższego czasu jaki stanowi różnica | 76.13%     | 68.54%     | 63.37%     |

    2. Czy czas wykonania programu z różnymi rozmiarami macierzy identyfikuje 
    rozmiary poszczególnych poziomów pamięci podręcznej?

        Jednoznaczne ustalenie rozmiaru poszczególnych poziomów pamięci podręcznej
    jest utrudnione przez fakt, iż jest to (w przypadku komputera testowego)
    pamięć zbiorowo asocjacyjna. Pamięć może być dostatecznie duża, aby pomieścić
    daną macierz, ale istnieje możliwość, iż dane nie będą równomiernie rozłożone
    pomiędzy zbiorami. W najgorszym przypadku wszystkie dane trafią do jednego
    zbioru.

---
Zadanie 4:
---

Pomysł:

    Zastąpienie wystąpień instrukcji warunkowych wyrażeniami z operatorem "?:".

Wyniki:

    Wygenerowany kod przed optymalizacją (ciało pętli, ~56 instrukcji):

    xor    %edx,%edx
    test   %ebx,%ebx
    setg   %dl
    sub    %edx,%ebx
    sub    $0x1,%ebp
    je     0xfbf <randwalk1+127>
    sub    $0x2,%r9d
    js     0xfd8 <randwalk1+152>
    mov    %ebx,%ecx
    shrx   %r9,%rax,%r8
    imul   %r15d,%ecx
    add    %r13d,%ecx
    movslq %ecx,%rcx
    movzbl (%r14,%rcx,1),%edx
    add    %edx,%r12d
    and    $0x3,%r8d
    je     0xf70 <randwalk1+48>
    cmp    $0x1,%r8d
    je     0xff0 <randwalk1+176>
    cmp    $0x2,%r8d
    je     0x1000 <randwalk1+192>
    xor    %edx,%edx
    cmp    %r13d,%esi
    setg   %dl
    add    %edx,%r13d
    sub    $0x1,%ebp
    jne    0xf7e <randwalk1+62>
    add    $0x18,%rsp
    mov    %r12d,%eax
    pop    %rbx
    pop    %rbp
    pop    %r12
    pop    %r13
    pop    %r14
    pop    %r15
    retq   
    nopl   0x0(%rax)
    xor    %eax,%eax
    mov    %esi,0xc(%rsp)
    callq  0x12b0 <fast_random>
    mov    $0x3e,%r9d
    mov    0xc(%rsp),%esi
    jmp    0xf84 <randwalk1+68>
    nop
    xor    %edx,%edx
    cmp    %ebx,%esi
    setg   %dl
    add    %edx,%ebx
    jmpq   0xf79 <randwalk1+57>
    xchg   %ax,%ax
    xor    %edx,%edx
    test   %r13d,%r13d
    setg   %dl
    sub    %edx,%r13d
    jmpq   0xf79 <randwalk1+57>


    Wygenerowany kod po optymalizacji (ciało pętli, ~57 instrukcji):

    mov    %ebx,%r8d
    shrx   %r9,%rax,%rcx
    imul   %r15d,%r8d
    add    %ebp,%r8d
    movslq %r8d,%r8
    movzbl (%r14,%r8,1),%esi
    add    %esi,%r13d
    test   %ebx,%ebx
    setg   %dil
    xor    %esi,%esi
    and    $0x3,%ecx
    sete   %sil
    and    %edi,%esi
    sub    %esi,%ebx
    cmp    $0x1,%ecx
    sete   %dil
    xor    %esi,%esi
    cmp    %edx,%ebx
    setl   %sil
    and    %edi,%esi
    add    %esi,%ebx
    test   %ebp,%ebp
    setg   %dil
    xor    %esi,%esi
    cmp    $0x2,%ecx
    sete   %sil
    and    %edi,%esi
    sub    %esi,%ebp
    cmp    %edx,%ebp
    setl   %sil
    cmp    $0x3,%ecx
    sete   %cl
    movzbl %cl,%ecx
    and    %esi,%ecx
    add    %ecx,%ebp
    sub    $0x1,%r12d
    je     1130 <randwalk2+0xc0>
    sub    $0x2,%r9d
    jns    10a0 <randwalk2+0x30>
    xor    %eax,%eax
    mov    %edx,0xc(%rsp)
    callq  12b0 <fast_random>
    mov    $0x3e,%r9d
    mov    0xc(%rsp),%edx
    jmpq   10a0 <randwalk2+0x30>
    nopl   0x0(%rax)
    add    $0x18,%rsp
    mov    %r13d,%eax
    pop    %rbx
    pop    %rbp
    pop    %r12
    pop    %r13
    pop    %r14
    pop    %r15
    retq   
    nopl   0x0(%rax)
    nopw   %cs:0x0(%rax,%rax,1)

| Wersja       | Liczba skoków warunkowych     | Liczba instrukcji sete/setl/setg |
|--------------|-------------------------------|----------------------------------|
| randwalk1    |              7                |                3                 |
| randwalk2    |              3                |                8                 |

Pomiary czasu w zależności od rozmiaru macierzy:

    Parametry:
    -S 0xea3495cc76b34acc
    -s 16
    -t 14

| v: | 0        |    0     |   0      | 1        |  1       |  1       |
|----|----------|----------|----------|----------|----------|----------|
| n: | 5        | 6        | 7        | 5        | 6        | 7        |
|    | 6.275456 | 6.343673 | 6.337812 | 3.429389 | 3.457285 | 3.301185 |
|    | 6.106140 | 6.058934 | 6.158242 | 3.423576 | 3.301643 | 3.255843 |
|    | 5.975087 | 6.313643 | 6.179230 | 3.449434 | 3.440906 | 3.396092 |
|    | 6.229435 | 6.227322 | 6.211287 | 3.367205 | 3.402375 | 3.355587 |
|    | 6.294365 | 6.349439 | 6.337404 | 3.262701 | 3.327759 | 3.263302 |
|    | 5.976061 | 6.013849 | 6.005589 | 3.262103 | 3.256738 | 3.254797 |
|    | 6.167224 | 6.073255 | 6.055543 | 3.474092 | 3.323924 | 3.495590 |
|    | 6.276128 | 6.437240 | 6.371622 | 3.357300 | 3.386998 | 3.392468 |
|    | 6.420004 | 6.352812 | 6.111955 | 3.326241 | 3.372135 | 3.415414 |
|    | 6.084836 | 6.085086 | 6.223412 | 3.303577 | 3.378353 | 3.331602 |
|    | 6.289081 | 6.004311 | 6.013003 | 3.412348 | 3.359372 | 3.362875 |
|    | 6.230479 | 6.148741 | 6.091662 | 3.345380 | 3.310502 | 3.315510 |
|    | 6.165195 | 6.292914 | 6.280018 | 3.377468 | 3.405375 | 3.411611 |
|    | 6.222765 | 6.160610 | 6.100761 | 3.307912 | 3.334782 | 3.297479 |
|    | 6.012171 | 6.061106 | 6.107603 | 3.324772 | 3.330368 | 3.353048 |
|    | 6.265307 | 6.124688 | 6.085445 | 3.296665 | 3.258919 | 3.433624 |
|    | 6.222481 | 6.216952 | 6.280967 | 3.377838 | 3.282266 | 3.300243 |
|    | 6.019576 | 5.979727 | 6.153087 | 3.365736 | 3.389019 | 3.424728 |
|    | 6.354676 | 6.395787 | 6.093068 | 3.280690 | 3.312881 | 3.393545 |
|    | 6.304428 | 6.167401 | 6.100358 | 3.373196 | 3.295989 | 3.346012 |
|    | 6.068080 | 6.233280 | 6.330227 | 3.452459 | 3.316887 | 3.449022 |
|    | 6.072692 | 6.020548 | 6.049431 | 3.303620 | 3.332536 | 3.256670 |
|    | 6.107064 | 6.125193 | 6.152727 | 3.326368 | 3.268038 | 3.256505 |
|    | 6.100081 | 6.125385 | 6.249076 | 3.438007 | 3.344403 | 3.325618 |
|    | 6.234771 | 6.186386 | 6.129911 | 3.328908 | 3.352335 | 3.352460 |

    Średnie wyniki:

| v:   | 0          |     0      |     0     | 1         | 1          | 1         |
|------|------------|------------|-----------|-----------|------------|-----------|
| n:   | 5          | 6          | 7         | 5         | 6          | 7         |
| avg: | 6,17894332 | 6,17993128 | 6,1683776 | 3,3586794 | 3,34167152 | 3,3496332 |

    Jak widać, rozmiar macierzy nie wpływa na czas działania programu.
    Można również zaobserwować, że optymalizacja pozwoliła przyspieszyć
    program o niemal połowę.

---
Zadanie 5:
---

    1. Czemu zmiana organizacji danych spowodowała przyspieszenie algorytmu wyszukiwania? 

        W przypadku oryginalnej organizacji danych podczas wyszukiwania binernego
    brakowało lokalności przestrzennej - kolejne wyznaczane środki przedziałów
    mogły leżeć w częściach tablicy, które nie znajdowały się w pamięci cache. 
    Pobrane dane były w większości bezużyteczne, bo dostęp dokonywany był jedynie do
    środkowego elementu w każdym przedziale.
        Jeżeli dane będą reprezentowane w postaci kopca binarnego, to umieściwszy
    kolejne poziomy drzewa liniowo w pamięci sprawimy, że kolejne elementy będą
    leżeć stosunkowo blisko siebie (a przynajmniej te z wyższych poziomów drzewa).
    Kolejne dostępy do pamięci zawsze muszą przejść przez kolejne poziomy kopca,
    więc mamy gwarancję, iż dane są ułożone są w kolejności, która wywoła
    minimalną ilość chybień pamięci cache.


Wyniki pomiarów:

| v:    | 0        | 0        | 0        | 1        | 1        | 1        |
|-------|----------|----------|----------|----------|----------|----------|
| n; t: | 15; 24   | 20; 20   | 24; 20   | 15; 24   | 20; 20   | 24; 20   |
|       | 0,754356 | 0,163381 | 0,724295 | 0,494728 | 0,068206 | 0,39018  |
|       | 0,733105 | 0,198228 | 0,709853 | 0,506609 | 0,068456 | 0,41239  |
|       | 0,74396  | 0,242022 | 0,677272 | 0,489025 | 0,080027 | 0,422154 |
|       | 0,745888 | 0,182237 | 0,764667 | 0,495188 | 0,072921 | 0,456996 |
|       | 0,754122 | 0,286927 | 0,726013 | 0,50551  | 0,083449 | 0,431434 |
|       | 0,730174 | 0,29561  | 0,74035  | 0,50227  | 0,089475 | 0,434126 |
|       | 0,722331 | 0,181046 | 0,738287 | 0,48494  | 0,079912 | 0,379176 |
|       | 0,759801 | 0,234535 | 0,691472 | 0,481271 | 0,078034 | 0,41074  |
|       | 0,748306 | 0,240529 | 0,673371 | 0,492424 | 0,074285 | 0,344862 |
|       | 0,733226 | 0,170938 | 0,722094 | 0,485005 | 0,069747 | 0,394639 |
|       | 0,732578 | 0,190656 | 0,675191 | 0,479937 | 0,080378 | 0,375131 |
|       | 0,722492 | 0,207083 | 0,690864 | 0,476291 | 0,07344  | 0,393499 |
|       | 0,733081 | 0,207047 | 0,698745 | 0,479891 | 0,073136 | 0,401842 |
|       | 0,722851 | 0,21288  | 0,713548 | 0,47339  | 0,074884 | 0,371572 |
|       | 0,737672 | 0,219984 | 0,711758 | 0,483617 | 0,073138 | 0,399958 |
|       | 0,718306 | 0,218165 | 0,700723 | 0,481132 | 0,074046 | 0,351175 |
|       | 0,720777 | 0,186736 | 0,676007 | 0,478301 | 0,069301 | 0,360339 |
|       | 0,718479 | 0,167763 | 0,679215 | 0,485388 | 0,078368 | 0,434354 |
|       | 0,72742  | 0,179596 | 0,761981 | 0,48139  | 0,069059 | 0,349909 |
|       | 0,70903  | 0,168548 | 0,795894 | 0,479809 | 0,068758 | 0,478516 |
|       | 0,73073  | 0,249535 | 0,724438 | 0,485996 | 0,086583 | 0,387766 |
|       | 0,740077 | 0,199797 | 0,71528  | 0,486358 | 0,073655 | 0,411346 |
|       | 0,775196 | 0,211345 | 0,758407 | 0,499849 | 0,076399 | 0,427092 |
|       | 0,748228 | 0,240811 | 0,717489 | 0,48786  | 0,082373 | 0,411688 |
|       | 0,74516  | 0,2006   | 0,743443 | 0,489581 | 0,083702 | 0,486838 |
|       | 0,756235 | 0,303828 | 0,731395 | 0,500389 | 0,08369  | 0,436081 |

| v:                   | 0          | 0          | 0          | 1          | 1          | 1          |
|----------------------|------------|------------|------------|------------|------------|------------|
| n; t:                | 15; 24     | 20; 20     | 24; 20     | 15; 24     | 20; 20     | 24; 20     |
| średni czas:             | 0,76654324 | 0,22239308 | 0,74648208 | 0,50744596 | 0,07941688 | 0,42215212 |
| poprawa w sekundach: | -          | -          | -          | 0,25909728 | 0,1429762  | 0,32432996 |
| % pierwotnego czasu jaki stanowi nowy czas | -          | -          | -          | 66,20%     | 35,71%     | 56,55%     |


    2. Czy odpowiednie ułożenie instrukcji w ciele «heap_search» poprawia wydajność wyszukań?

        Rozpatrzmy trzy wersje pętli w funkcji:

        1)

            do 
            {
                int y = arr[i - 1];
                long j = i * 2;

                if (y == x)
                    return true;

                j |= (y < x);

                i = j;
            }
            while (i <= size);

            po skompilowaniu:

            0x0000000000001090 <+0>:	mov    $0x1,%eax
            0x0000000000001095 <+5>:	jmp    0x10ae <heap_search+30>
            0x0000000000001097 <+7>:	nopw   0x0(%rax,%rax,1)
            0x00000000000010a0 <+16>:	setl   %al
            0x00000000000010a3 <+19>:	movzbl %al,%eax
            0x00000000000010a6 <+22>:	or     %rcx,%rax
            0x00000000000010a9 <+25>:	cmp    %rsi,%rax
            0x00000000000010ac <+28>:	jg     0x10c0 <heap_search+48>
            0x00000000000010ae <+30>:	lea    (%rax,%rax,1),%rcx
            0x00000000000010b2 <+34>:	cmp    %edx,-0x4(%rdi,%rax,4)
            0x00000000000010b6 <+38>:	jne    0x10a0 <heap_search+16>
            0x00000000000010b8 <+40>:	mov    $0x1,%eax
            0x00000000000010bd <+45>:	retq   
            0x00000000000010be <+46>:	xchg   %ax,%ax
            0x00000000000010c0 <+48>:	xor    %eax,%eax
            0x00000000000010c2 <+50>:	retq  

        2)

            do 
            {
                int y = arr[i - 1];
                
                if (y == x)
                    return true;

                long j = i * 2;

                j |= (y < x);

                i = j;
            }
            while (i <= size);

            po skompilowaniu:

            0x0000000000001090 <+0>:	mov    $0x1,%eax
            0x0000000000001095 <+5>:	jmp    0x10b3 <heap_search+35>
            0x0000000000001097 <+7>:	nopw   0x0(%rax,%rax,1)
            0x00000000000010a0 <+16>:	add    %rax,%rax
            0x00000000000010a3 <+19>:	cmp    %edx,%ecx
            0x00000000000010a5 <+21>:	setl   %cl
            0x00000000000010a8 <+24>:	movzbl %cl,%ecx
            0x00000000000010ab <+27>:	or     %rcx,%rax
            0x00000000000010ae <+30>:	cmp    %rsi,%rax
            0x00000000000010b1 <+33>:	jg     0x10c8 <heap_search+56>
            0x00000000000010b3 <+35>:	mov    -0x4(%rdi,%rax,4),%ecx
            0x00000000000010b7 <+39>:	cmp    %edx,%ecx
            0x00000000000010b9 <+41>:	jne    0x10a0 <heap_search+16>
            0x00000000000010bb <+43>:	mov    $0x1,%eax
            0x00000000000010c0 <+48>:	retq   
            0x00000000000010c1 <+49>:	nopl   0x0(%rax)
            0x00000000000010c8 <+56>:	xor    %eax,%eax
            0x00000000000010ca <+58>:	retq  

        3)

            do 
            {
                int y = arr[i - 1];
                long j = i * 2;

                j |= (y < x);

                i = j;
                
                if (y == x)
                    return true;
            }
            while (i <= size);

            po skompilowaniu:

            0x0000000000001090 <+0>:	mov    $0x1,%eax
            0x0000000000001095 <+5>:	jmp    0x10a5 <heap_search+21>
            0x0000000000001097 <+7>:	nopw   0x0(%rax,%rax,1)
            0x00000000000010a0 <+16>:	cmp    %rsi,%rax
            0x00000000000010a3 <+19>:	jg     0x10c8 <heap_search+56>
            0x00000000000010a5 <+21>:	mov    -0x4(%rdi,%rax,4),%ecx
            0x00000000000010a9 <+25>:	xor    %r8d,%r8d
            0x00000000000010ac <+28>:	add    %rax,%rax
            0x00000000000010af <+31>:	cmp    %edx,%ecx
            0x00000000000010b1 <+33>:	setl   %r8b
            0x00000000000010b5 <+37>:	or     %r8,%rax
            0x00000000000010b8 <+40>:	cmp    %edx,%ecx
            0x00000000000010ba <+42>:	jne    0x10a0 <heap_search+16>
            0x00000000000010bc <+44>:	mov    $0x1,%eax
            0x00000000000010c1 <+49>:	retq   
            0x00000000000010c2 <+50>:	nopw   0x0(%rax,%rax,1)
            0x00000000000010c8 <+56>:	xor    %eax,%eax
            0x00000000000010ca <+58>:	retq  

Pomiary prędkości działania poszczególnych wersji funkcji:

    Parametry:
    -S 0x5bab3de5da7882ff 
    -n 22 
    -t 23 
    -v 1

| wersja:    | 1)       | 2)        | 3)        |
|------------|----------|-----------|-----------|
| średnia:   | 1,434258 | 1,4835579 | 1,3924005 |
| pomiar 1:  | 1.455187 | 1.417410  | 1.434918  |
| pomiar 2:  | 1.395226 | 1.443129  | 1.385459  |
| pomiar 3:  | 1.429496 | 1.449624  | 1.385760  |
| pomiar 4:  | 1.429328 | 1.414286  | 1.381046  |
| pomiar 5:  | 1.413394 | 1.480518  | 1.394749  |
| pomiar 6:  | 1.436421 | 1.481839  | 1.351523  |
| pomiar 7:  | 1.424371 | 1.517968  | 1.384890  |
| pomiar 8:  | 1.421022 | 1.561896  | 1.377048  |
| pomiar 9:  | 1.445126 | 1.565330  | 1.385365  |
| pomiar 10: | 1.493009 | 1.503579  | 1.443247  |

        Jak widać, różnice w czasie są minimalne. Wersja, w której instrukcja warunkowa
    if (y == x) znajduje się na końcu funkcji, jest najszybsza. Wynika to prawdopodobnie
    z tego, że instrukcja skoku (służąca do opuszczenia pętli) w skompilowanym programie
    znajduje się na jego początku (w przeciwieństwie do wersji 1) i 2)).



